A* algorithm pseudocode

Διάκριση μεταξύ "τελεστή" και "υλοποίησης τελεστή". Ένας τελεστής μπορεί να έχει πολλαπλές υλοποιήσεις σε διαφορετικές πλατφόρμες/clusters

##PART_1
- Πρόσθεσε έναν END_OR κόμβο που να λαμβάνεις την έξοδο όλων των Operators που δεν έχουν outgoing edge
- Πρόσθεσε έναν START_OR κόμβο που δινει είσοδο σε όλους τους τελεστές που δεν έχουν incoming edge απο άλλο τελεστή

##PART_2
- Topological sort στο γράφο και αποθήκευση πχ σε μία διπλά συνδεδεμένη λίστα
- Κάλεσε μία συνάρτηση compute_h(), η οποία με reverse topological sort υπολόγισε το κάτω όριο h(op) του να οδηγηθούμε
 από μία υλοποίηση τελεστή op ως τον END_OR. Αρχικά βάλε το 0 παντού και θα το εξηγήσω σε άλλο μήνυμα το πώς υπολογίζεται.
- Σημείωση: Το h(op) θα είναι ένα ανά τελεστή και ΙΔΙΟ για όλες τις υλοποιήσεις του τελεστή.

##PART_3
- Φτιάχνουμε ένα priority queue με λύσεις. Οι λύσεις είναι ταξινομημένες με την εκτίμηση κόστους του να φτάσουμε ως το END_OR.
Για κάθε λύση, θα πρεπει να υπολογίζουμε και να αποθηκεύουμε
(α) Το σετ των τελεστών (θα είναι υλοποιήσεις τελεστών) EndingNodes που είναι στη λύση και ΔΕΝ εχουν
    όλους τους outgoing τελεστες τους στη λύση.
(b) Για κάθε Χ στο EndingNodes, το πραγματικό κόστος cost(X) του να φτάσουμε ως αυτόν.
(c) Για κάθε Χ στο EndingNodes, το εκτιμόμενο κόστος cost(X)+h(X) του να φτάσουμε ως ton END_OR.
(d) Το μέγιστο από όλα τα κόστη που υπάρχουν στο  (c). Αυτό θα είναι η εκτίμηση κόστους όλης της λύσης.

##PART_4
- Ξεκινάμε από μία μόνο λύση που περιέχει το START_OR

- Σε loop
   - Βγάζουμε από το priority queue τη λύση SOL με το μικρότερο εκτιμόμενο κόστος.

   - Κάλεσε μία συνάρτηση selectOpToAdd, η οποία επιλέγει έναν operator newOP που ΔΕΝ
     είναι ήδη στη SOL, αλλά έχει όλους τους incoming operators στη SOL. Αυτό μπορεί να στο
     δώσει και το topological sort έτοιμο.
     Αν υπάρχουν πολλοί, επέλεξε εναν τυχαία
     Σημείωση: Αυτό δεν είναι βέλτιστο, αλλά θα το διορθώσω σε επόμενο email.

  - Αντικατέστησε τη SOL, την οποία επεκτείνεις.
    Δημιούργησε τόσες καινούργιες λύσεις SOLj, όσες οι δυνατές υλοποιήσεις τους SOL.
    Κάθε λύση προσθέτει ακμές από ΟΛΟΥΣ τους incoming dictionaryOperators προς μία συγκεκριμένη
    υλοποίηση του τελεστή που πρόσθεσες.
    Για κάθε λύση υπολόγισε τα 4 στοιχεία της που έγραψα παραπάνω. Όλα υπολογίζονται
    incrementally.
    Σημείωση: η μετάβαση το κόστος της SOLj για το μονοπάτι προς τον τελεστή που προστέθηκε
                      προκυπτει ως cost(SOL) + transmit(SOL->newOpImpl) + cost(newOpImpl)
                      και πρέπει να υπολογιστεί για ΟΛΑ τα μονοπάτια που οδηγουν σε αυτόν, και να  λαβουμε το max από αυτά.
                      Το transmit (SOL->newOP)+cost(newOp) θέλει λίγη προσοχή.

    Μετά ενημερώνουμε το ENDINGNODES της λυσης, τα κόστη τους (πρόσεξε ότι
                      κάποιες από τους τελεστές που έδιναν είσοδο στον τελεστή που μόλις προσθέσαμε
                      ΙΣΩΣ να πρέπει να αφαιρεθούν από το ENDINGNODES σετ).

    Μετά υπολογίζουμε το συνολικό κόστος της κάθε λύσης SOLj με έναν max τελεστή.

  - Λύσεις που χρησιμοποιούνται για pruning είναι μόνο αυτές που έχουν φτάσει στον END_OR
    τελεστή

  - Λύσεις με εκτιμόμενο κόστος >= το minimum κόστος λύσης που έχει ήδη φτάσει στον END_OR απορρίπτονται
  (για την ακρίβεια, στην priority queue θα μείνουν στο τέλος και μπορουμε όλες μαζί να τις πετάξουμε.


email

Έχω εγώ ως επόμενους τους Α, Β, Γ

Για κάθε επόμενο τελεστή

(α) Υπολογιζω το μίνιμουμ κόστος του τελεστή σε οποιαδήποτε πλατφόρμα και το αθροίζω με το h()  τελεστή αυτού

(β) Το δικό μου h() είναι το max από τα αθροίσματα που υπολόγισα στους επόμενους τελεστές μου

(γ) Αρχικοποίηση: κόστος του τελικού OR = 0, h(FINAL_OR) = 0

Για όλο το πλάνο (που είναι γράφος κάθε φορά), το cost+h() που θα βάλεις στο priority queue είναι το MAX από αυτά των ending nodes του
